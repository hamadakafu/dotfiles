snippet rand_range "rand range"
	let mut rng = rand::thread_rng();
	(0..size).map(|_| rng.gen_range(1, 2)).collect();
endsnippet

snippet use_kyopro "競プロでよく使うcrate"
use std::cmp::{min, max};
use std::collections::{HashMap, HashSet};
use std::cmp::Reverse;

use itertools::Itertools;
use whiteread::parse_line;

const ten97: usize = 1000_000_007;

fn main() { }
endsnippet

snippet alphabet2idx "alphabetをusizeに変換" b
fn alphabet2idx(c: char) -> usize {
    if !c.is_ascii_alphabetic() {
        panic!("{} is not ascii alphabetic!", c)
    }
    (c.to_digit(36).unwrap() - 'a'.to_digit(36).unwrap()) as usize
}

#[cfg(test)]
mod tests {
    use crate::{alphabet2idx};
    #[test]
    fn test_alphabet() {
        let cases = vec![('a', 0), ('A', 0), ('z', 25), ('Z', 25), ('d', 3)];
        for (c, ans) in cases {
            assert_eq!(alphabet2idx(c), ans);
        }
    }
}
endsnippet

snippet union_find "Union Find"
#[derive(Debug)]
/// UnionFindは何らかの構造に対して同値類を求めるようなアルゴリズム
pub struct UnionFind {
    /// parents[index]はindexの対する親のindexが入っている
    pub parents: Vec<usize>,
    /// sizes[index]は子どもたちの数みたいなもの
    /// 大きい木に小さい木をつけることで効率よくfindできる
    pub sizes: Vec<usize>,
}
impl UnionFind {
    pub fn new(n: usize) -> Self {
        let mut parents: Vec<usize> = Vec::with_capacity(n);
        for i in 0..n {
            parents.push(i);
        }
        let sizes = vec![1; n];
        UnionFind { parents, sizes }
    }
    /// 再帰的にparentsからxの親を順番ずつ見ていき親を更新しつつxの親を求める
    pub fn find(&mut self, x: usize) -> usize {
        if self.parents[x] == x {
            x
        } else {
            let par = self.parents[x];
            let root = self.find(par);
            self.parents[x] = root;
            root
        }
    }
    /// union x and y
    /// ルートを付け替えるだけで，
    /// 新たに付け加えられた木の子どもたちの親は変わらないことに注意
    /// unionしたあとも find を呼ぶ必要がある．
    /// rootが同じ場合はunionに失敗する
    pub fn union(&mut self, x: usize, y: usize) -> bool {
        let x_root = self.find(x);
        let y_root = self.find(y);
        // if x_root == y_root, do nothing
        if x_root == y_root {
            return false;
        }
        if self.sizes[x_root] > self.sizes[y_root] {
            // x <--- y  y親がxになる
            self.sizes[x_root] += self.sizes[y_root];
            self.parents[y_root] = x_root;
        } else {
            // y <--- x xの親がyになる
            self.sizes[y_root] += self.sizes[x_root];
            self.parents[x_root] = y_root;
        }
        true
    }

    /// 呼び出す前にfindを計算する必要はない
    pub fn size(&mut self, x: usize) -> usize {
        let r = self.find(x);
        self.sizes[r]
    }
}
endsnippet

snippet nCr "組み合わせの個数" b
/// 極力u64を超えないようにnCrを計算する
fn nCr(n: u64, r: u64) -> u128 {
    if n < r {
        panic!("cant n < r, {}C{}", n, r);
    }
    if r == 0 {
        return 0;
    }

    let mut ans: u128 = 1;
    if r > n - r {
        let mut bunbo = (1..=n - r).rev().collect::<Vec<u64>>();
        for i in r + 1..=n {
            ans *= i as u128;
            if let Some(last) = bunbo.get(bunbo.len() - 1) {
                if ans % *last as u128 == 0 {
                    ans /= *last as u128;
                    bunbo.pop();
                }
            }
        }
    } else {
        let mut bunbo = (1..=r).rev().collect::<Vec<u64>>();
        for i in n - r + 1..=n {
            ans *= i as u128;
            if let Some(last) = bunbo.get(bunbo.len() - 1) {
                if ans % *last as u128 == 0 {
                    ans /= *last as u128;
                    bunbo.pop();
                }
            }
        }
    }
    return ans;
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_nCr() {
        assert_eq!(nCr(5, 2), 10);
        assert_eq!(nCr(5, 3), 10);
        assert_eq!(nCr(1, 1), 1);
        assert_eq!(nCr(5, 1), 5);
        assert_eq!(nCr(5, 0), 0);
        assert_eq!(nCr(2_u64 * 100000, 2), 19999900000);
    }
}
endsnippet

snippet combination "Vec<T>のcombinationの列挙" b
fn combination<T: Clone>(xs: Vec<T>, n: u64) -> Vec<Vec<T>> {
    if (xs.len() as u64) < n {
        return vec![];
    }

    let mut ans = vec![];

    if n == 1 {
        return xs.into_iter().map(|x| vec![x]).collect();
    }
    let mut xs_1 = xs.clone();
    let x = xs_1.pop().unwrap();

    let xs_1 = combination(xs_1, n - 1);
    ans.append(
        &mut xs_1
            .into_iter()
            .map(|mut xs| {
                xs.push(x.clone());
                xs
            })
            .collect(),
    );
    let mut xs_1 = xs.clone();
    xs_1.pop();
    ans.append(&mut combination(xs_1, n));

    return ans;
}
endsnippet

snippet bits_tansaku "bits全探索" b

let ${1:vec} = vec![100;n];
for mut bits in 0..2_u64.pow($1.len() as u32) {
    let mut vv = vec![];
    for i in 0..$1.len() {
        if bits % 2 == 1 {
            vv.push($1[i]);
        }
        bits /= 2;
    }
    $0
}
endsnippet

snippet "lower_bound_upper_bound" "c++のlower_boundとupper_boundのVec実装" b
trait LUBound<T> {
    fn lower_bound(&self, value: T) -> usize
    where
        T: PartialOrd;
    fn upper_bound(&self, value: T) -> usize
    where
        T: PartialOrd;
}
impl<T> LUBound<T> for Vec<T> {
    fn lower_bound(&self, value: T) -> usize
    where
        T: PartialOrd,
    {
        let mut left = 0;
        let mut right = self.len();
        while left < right {
            let pivot = (right + left) / 2;
            if value <= self[pivot] {
                right = pivot;
            } else {
                left = pivot + 1;
            }
        }
        return left;
    }

    fn upper_bound(&self, value: T) -> usize
    where
        T: PartialOrd,
    {
        let mut left = 0;
        let mut right = self.len();
        while left < right {
            let pivot = (right + left) / 2;
            if value < self[pivot] {
                right = pivot;
            } else {
                left = pivot + 1;
            }
        }
        return left;
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn lower_bound() {
        let cases = vec![(
            vec![0, 1, 1, 1, 2, 2, 3, 5],
            (-1..=6),
            vec![0, 0, 1, 4, 6, 7, 7, 8],
        )];
        for case in cases {
            for (value, expected) in case.1.zip(case.2.into_iter()) {
                assert_eq!(case.0.lower_bound(value), expected);
            }
        }
    }
    #[test]
    fn upper_bound() {
        let cases = vec![(
            vec![0, 1, 1, 1, 2, 2, 3, 5],
            (-1..=6),
            vec![0, 1, 4, 6, 7, 7, 8, 8],
        )];
        for case in cases {
            for (value, expected) in case.1.zip(case.2.into_iter()) {
                assert_eq!(case.0.upper_bound(value), expected);
            }
        }
    }
}
endsnippet

snippet Bubunwa "O(self.len() * value) 配列の部分和がvalueとなるようなsubsetが存在するかcheckする" b
/// u64 or usize
trait Bubunwa {
    fn bubunwa_usize(&self, value: usize) -> bool;
    fn bubunwa_u64(&self, value: u64) -> bool;
}

impl Bubunwa for Vec<usize> {
    fn bubunwa_usize(&self, value: usize) -> bool {
        let mut dp: Vec<bool> = vec![false; value + 1];
        dp[0] = true;

        for i in 0..self.len() {
            if value < self[i] {
                continue;
            }
            for j in (0..=value - self[i]).rev() {
                if dp[j] {
                    dp[j + self[i]] = true;
                }
            }
        }
        //    dbg!(&dp);
        dp[value]
    }

    fn bubunwa_u64(&self, value: u64) -> bool {
        let value: usize = value as usize;
        let mut dp: Vec<bool> = vec![false; value + 1];
        dp[0] = true;

        for i in 0..self.len() {
            if value < self[i] {
                continue;
            }
            for j in (0..=value - self[i]).rev() {
                if dp[j] {
                    dp[j + self[i]] = true;
                }
            }
        }
        //    dbg!(&dp);
        dp[value]
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_bubunwa_usize() {
        let cases = vec![(
            vec![8, 3, 7, 2, 5],
            (0..20_usize),
            vec![
                true, false, true, true, false, true, false, true, true, true, true, true, true,
                true, true, true, true, true, true, false,
            ],
        )];
        for case in cases {
            for (value, &real) in case.1.zip(case.2.iter()) {
                assert_eq!(case.0.bubunwa_usize(value), real);
            }
        }
    }
    #[test]
    fn test_bubunwa_u64() {
        let cases = vec![(
            vec![8, 3, 7, 2, 5],
            (0..20_u64),
            vec![
                true, false, true, true, false, true, false, true, true, true, true, true, true,
                true, true, true, true, true, true, false,
            ],
        )];
        for case in cases {
            for (value, &real) in case.1.zip(case.2.iter()) {
                assert_eq!(case.0.bubunwa_u64(value), real);
            }
        }
    }
}
endsnippet

snippet dfs "深さ優先探索" b
let mut already = HashSet::new();
let mut stack = vec![1];
already.insert(1);
// この段階で1は調査済みであるので，
// 1に対して処理すべきことは済ましておく
while !stack.is_empty() {
    let t = stack.pop().unwrap();
    for p in paths[t].iter() {
        if !already.insert(*p) {
            continue;
        }
        stack.push(*p);
				// pに対してなんかする
    }
}
endsnippet

snippet for_char "charのfor文" b
for c in (b'a'..=b'z').map(char::from) {
}
endsnippet

snippet gcd_lcm "gcd" b
fn lcm(a: usize, b: usize) -> usize {
    a * b / gcd(a, b)
}

fn gcd(a: usize, b: usize) -> usize {
    if a > b {
        let tmp = a % b;
        if tmp == 0 {
            b
        } else {
            gcd(b, tmp)
        }
    } else {
        let tmp = b % a;
        if tmp == 0 {
            a
        } else {
            gcd(a, tmp)
        }
    }
}
endsnippet


snippet dijkstra "ダイクストラ法" b
let mut queue: BinaryHeap<(Reverse<usize>, usize)> = BinaryHeap::new();
let mut already: Vec<bool> = vec![false; n + 1];
let mut dis1: Vec<usize> = vec![std::usize::MAX; n + 1];
queue.push((Reverse(0), 1));
already[1] = true;
dis1[1] = 0;
while !queue.is_empty() {
    let (Reverse(hun), machi) = queue.pop().unwrap();
    dis1[machi] = min(dis1[machi], hun);
    already[machi] = true;

    // // 最後の街だけ調査したいならここでbreak
    // if machi == n {
    //     break;
    // }

    for p in paths[machi].iter() {
        if !already[p.0] {
            queue.push((Reverse(hun + p.1), p.0));
        }
    }
}
endsnippet

snippet SCC "強連結成分(SCC)" b
/// n: nodeの数
/// paths:
fn scc(n: usize, paths: &Vec<Vec<usize>>) -> Vec<Vec<usize>> {
    fn dfs(
        index: &mut Vec<usize>,
        counter: &mut usize,
        now: usize,
        already: &mut Vec<bool>,
        paths: &Vec<Vec<usize>>,
    ) {
        for p in paths[now].iter() {
            if !already[*p] {
                already[*p] = true;
                dfs(index, counter, *p, already, paths);
                *counter += 1;
                index[*counter] = *p;
            }
        }
    }

    // 帰り順にindexに数字が入る
    let mut already: Vec<bool> = vec![false; n + 1];
    let mut index: Vec<usize> = vec![0; n + 1];
    let mut counter = 0;
    for i in 1..=n {
        if already[i] {
            continue;
        }
        already[i] = true;
        dfs(&mut index, &mut counter, i, &mut already, &paths);
        counter += 1;
        index[counter] = i;
    }
    let mut invpaths: Vec<Vec<usize>> = vec![vec![]; n + 1];
    for (s, sp) in paths.iter().enumerate() {
        for g in sp.iter() {
            invpaths[*g].push(s);
        }
    }

    // 大きい数字からDFS(invpathsのグラフにおいて最下流からDFS)
    let mut already = vec![false; n + 1];
    let mut groups: Vec<Vec<usize>> = vec![];
    for i in (1..=n).rev() {
        let s = index[i];
        let mut group = vec![];
        if already[s] {
            continue;
        }
        let mut stack = vec![s];
        already[s] = true;
        while !stack.is_empty() {
            let t = stack.pop().unwrap();
            group.push(t);
            for p in invpaths[t].iter() {
                if already[*p] {
                    continue;
                }
                stack.push(*p);
                already[*p] = true;
            }
        }
        groups.push(group);
    }
    return groups;
}
endsnippet

snippet base_change "基数変換" b
fn to_usize(s: &str, base: usize) -> usize {
    let mut tmp = 1;
    let mut ans = 0;
    for c in s.chars().rev() {
        ans += tmp * c.to_digit(base as u32).unwrap() as usize;
        tmp *= base;
    }
    ans
}
fn from_usize(num: usize, base: usize) -> String {
    if num == 0 {
        return "0".to_string();
    }
    let mut tmp = num;
    let mut ans = vec![];
    while tmp > 0 {
        ans.push((tmp % base).to_string());
        tmp /= base;
    }
    ans.into_iter().rev().join("")
}

#[cfg(test)]
mod tests {
    use crate::{from_usize, to_usize};

    #[test]
    fn test_to_usize() {
        let cases = vec![("0", 8, 0), ("77", 8, 63), ("76", 8, 62), ("16", 8, 14)];
        for (s, base, ans) in cases {
            assert_eq!(to_usize(s, base), ans);
        }
    }
    #[test]
    fn test_from_usize() {
        let cases = vec![(0, 8, "0"), (63, 8, "77"), (62, 8, "76"), (14, 8, "16")];
        for (s, base, ans) in cases {
            assert_eq!(from_usize(s, base), ans);
        }
    }
}
endsnippet

snippet mypow "バイナリ法 binary" b
fn mypow(a: usize, mut b: usize, mmm: usize) -> usize {
    let mut ans = 1;
    let mut ppp = a;
    while b > 0 {
        if b % 2 == 1 {
            ans *= ppp;
            ans %= mmm;
        }
        ppp *= ppp;
        ppp %= mmm;

        b /= 2;
    }
    ans
}
endsnippet

snippet factorize "素因数分解" b
fn bunkai(mut n: usize) -> Vec<usize> {
    let mut ans = vec![];
    let mut pivot = 2;

    while pivot * pivot <= n {
        while n / pivot * pivot == n {
            ans.push(pivot);
            n /= pivot;
        }
        pivot += 1;
    }
    if n != 1 {
        ans.push(n);
    }
    ans
}
endsnippet

snippet imosu2d "2次元いもす法" b
let n: usize = parse_line().unwrap();
let ookisa = 1002;
// 累積和がheimenに入っている
let mut heimen: Vec<Vec<isize>> = vec![vec![0; ookisa]; ookisa];
for _ in 0..n {
    let (lx, ly, rx, ry): (usize, usize, usize, usize) = parse_line().unwrap();
    heimen[lx][ly] += 1;
    heimen[rx][ry] += 1;
    heimen[lx][ry] -= 1;
    heimen[rx][ly] -= 1;
}

// x方向に走査
for x in 1..ookisa {
    for y in 0..ookisa {
        heimen[x][y] += heimen[x - 1][y];
    }
}
// y方向に走査
for x in 0..ookisa {
    for y in 1..ookisa {
        heimen[x][y] += heimen[x][y - 1];
    }
}
endsnippet
